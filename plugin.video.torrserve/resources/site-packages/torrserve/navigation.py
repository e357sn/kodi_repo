# -*- coding: utf-8 -*-

import os
import json
import time
import urllib
import re

import xbmc
import xbmcgui
import xbmcplugin

from client import client, touch
from config import TORRSERVED_HOST, ADDON_PATH
from simpleplugin import Plugin
from utils import humanizeSize, notify, settingsIsOpen, parseName

plugin = Plugin()
translate = plugin.initialize_gettext()


@plugin.action()
def root():
    resp = client("/echo")
    if not resp:
        notify(translate("Server is down") % TORRSERVED_HOST)
        return
    else:
        listing = get_listing("index")
        return Plugin.create_listing(listing, category="TorrServer: v"+resp)

def get_listing(params):
    listing = []
    if params == "index":
        listing.append({
            'label': translate("Torrents List"),
            'url': plugin.get_url(action='torrents', mod='list'),
            'icon': os.path.join(ADDON_PATH, "resources", "img", "list.png"),
            'is_folder': True
        })
        listing.append({
            'label': translate("Search"),
            'url': plugin.get_url(action="search", mod="index"),
            'icon': os.path.join(ADDON_PATH, "resources", "img", "search.png"),
            'is_folder': True
        })
        listing.append({
            'label': translate("Settings"),
            'icon': os.path.join(ADDON_PATH, "resources", "img", "settings.png"),
            'url': plugin.get_url(action='settings', mod='open'),
            'is_folder': False
        })
    elif params == "torrents":
        request = int(plugin.get_setting("without_info", True))
        resp = client("/torrent/list", post_data={"Request": request})
        for t in resp:
            listing.append({
                "label": u"[{0}] {1}".format(humanizeSize(t['Length']), parseName(t['Name'])),
                "url": plugin.get_url(action="torrents", mod="files", hash=t['Hash']),
                "icon": os.path.join(ADDON_PATH, "resources", "img", "magnet.png"),
                "context_menu": [(
                        translate("Delete from DB"),
                        "RunPlugin(%s)" % plugin.get_url(action="torrents", mod="delete", hash=t["Hash"]),
                    )],
            })
    return listing


@plugin.action("search")
def search(params):
    listing = []
    if params.mod == "index":
        dialog = xbmcgui.Dialog()
        query = dialog.input("Yohoho", type=xbmcgui.INPUT_ALPHANUM)
        if query:
            query = query.replace(" ", "%20")
            result = client("/", get_data={'title': query}, host='http://4h0y.yohoho.cc')
            if not result:
                notify(translate("Empty result"))
                return False
            match = re.finditer(r"href =.+?'(magnet:\?.+?)';\">(.+?)<\/span>.+?<div.+?>(.+?)<", result, re.DOTALL)
            for t in match:
                size = 0
                stringSize = t.group(3).replace('&nbsp;', ' ')
                if "МБ" in stringSize:
                    size = int(stringSize[:3]) * 2<<19
                else:
                    size = float(stringSize[:-4]) * float(2<<29)
                listing.append({
                    "label": u"{0}".format(parseName(t.group(2).decode('utf-8'))),
                    "label2": stringSize,
                    'url': plugin.get_url(action='play_now', magnet=t.group(1).decode('utf-8')),
                    'info': {'video': {'size': long(size),}},
                    'is_folder': False,
                    "is_playable": True,
                    "context_menu": [(
                        translate("Add to DB"),
                        "RunPlugin(%s)" % plugin.get_url(action="torrents", mod="add", magnet=t.group(1)),
                    )]
                })
            return Plugin.create_listing(listing, category="{0}: {1}".format(translate("Search"), query), sort_methods=(2, xbmcplugin.SORT_METHOD_SIZE), cache_to_disk=True)
    return False

@plugin.action("torrents")
def torrents(params):
    listing = []
    if params.mod == "list":
        listing = get_listing("torrents")
    elif params.mod == "files":
        listing = makeFileList(params.hash)
    elif params.mod == "add":
        client("/torrent/add", post_data={"Link": params.magnet})
        notify("Saved!")
        return
    elif params.mod == "delete":
        client("/torrent/rem", post_data={"Hash": params.hash})
        notify("Deleted!")
        xbmc.executebuiltin("Container.Refresh")
        return
    return Plugin.create_listing(listing, content="videos", category="Torrents")

@plugin.action()
def settings(params):
    if params.mod == "open":
        resp = client("/settings/read", post_data={"read": 1})
        for k, v in resp.items():
            if k == "CacheSize" or k == "PreloadBufferSize":
                v = (v / 1024) / 1024
            plugin.set_setting(k, str(v).lower())
        plugin.addon.openSettings()
        while settingsIsOpen():
            continue

        jset = {
            "CacheSize": plugin.get_setting("CacheSize", True) * 1024 * 1024,
            "PreloadBufferSize": plugin.get_setting("PreloadBufferSize", True) * 1024 * 1024,
            "RetrackersMode": plugin.get_setting("RetrackersMode", True),
            "DisableTCP": plugin.get_setting("DisableTCP", True),
            "DisableUTP": plugin.get_setting("DisableUTP", True),
            "DisableUPNP": plugin.get_setting("DisableUPNP", True),
            "DisableDHT": plugin.get_setting("DisableDHT", True),
            "DisableUpload": plugin.get_setting("DisableUpload", True),
            "Encryption": plugin.get_setting("Encryption", True),
            "DownloadRateLimit": plugin.get_setting("DownloadRateLimit", True),
            "UploadRateLimit": plugin.get_setting("UploadRateLimit", True),
            "ConnectionsLimit": plugin.get_setting("ConnectionsLimit", True),
            "PeersListenPort": plugin.get_setting("PeersListenPort", True)
        }
        client("/settings/write", post_data=jset)
        client("/torrent/restart")

@plugin.action("play")
def play(params):
    touch("{0}{1}".format(TORRSERVED_HOST, params.link))
    hash = params.link[17:57]
    success = makePreloadDialog(hash)
    return Plugin.resolve_url(TORRSERVED_HOST + params.link.replace('/preload/', '/view/'), succeeded=success)

@plugin.action("play_now")
def play_now(params):
    pDialog = xbmcgui.DialogProgress()
    pDialog.create("TorrServer", translate("Wait for info..."))
    success = False
    counter = 0
    selFile = None
    while True:
        if pDialog.iscanceled() :
            pDialog.close()
            client("/torrent/drop", post_data={"Hash": params.magnet[20:60]})
            break
        time.sleep(0.5)
        stat = client("/torrent/play", get_data={"stat": "true", "link": params.magnet, })
        if stat is None or len(stat['FileStats']) == 0:
            counter += 1
            if counter < 60:
                time.sleep(0.5)
                continue
            else:
                pDialog.close()
                break
        if len(stat['FileStats']) > 1 and selFile is None:
            sDialog = xbmcgui.Dialog()
            filelist = []
            for f in stat['FileStats']:
                filelist.append(f['Path'])
            sel = sDialog.select('Choose a file', filelist)
            if sel == -1:
                client("/torrent/drop", post_data={"Hash": stat['Hash']})
                break
            else:
                selFile = sel
                continue
        elif len(stat['FileStats']) == 1 and selFile is None:
            selFile = 0
            continue
        else:
            pDialog.close()
            preload = touch(TORRSERVED_HOST + "/torrent/play?link="+params.magnet+"&file="+str(selFile)+"&save="+str(plugin.get_setting("save_in_db", True)))
            success = makePreloadDialog(stat['Hash'])
            break
    return Plugin.resolve_url(TORRSERVED_HOST + "/torrent/play?link="+params.magnet+"&file="+str(selFile), succeeded=success)

def makeFileList(hash):
    request = int(plugin.get_setting("without_info", True))
    response = client("/torrent/list", post_data={"Request": request})
    listing = []
    for t in response:
        if t['Hash'] == hash :
            for f in t['Files']:
                listing.append({
                    "label": parseName(f['Name']),
                    "title": f['Name'],
                    "url": plugin.get_url(action="play", link=f['Preload'].encode("utf-8", "replace")),
                    "is_playable": True,
                    "info": {"video": {
                        'size': f['Size'],
                        'playcount': int(f['Viewed'])
                    }}
                })
    return listing

def makePreloadDialog(hash):
    pDialog = xbmcgui.DialogProgress()
    pDialog.create("TorrServer", translate("Wait for info..."))
    success = False
    counter = 0
    while True:
        if pDialog.iscanceled() :
            pDialog.close()
            client("/torrent/drop", post_data={"Hash": hash})
            break
        time.sleep(0.5)
        stat = client("/torrent/stat", post_data={"Hash": hash})
        if stat is None:
            counter += 1
            if counter < 60:
                time.sleep(0.5)
                continue
            else:
                pDialog.close()
                break
        name = parseName(stat['Name'])
        downSpeed = humanizeSize(stat['DownloadSpeed'])
        preloadedBytes = stat['PreloadedBytes']
        preloadSize = stat['PreloadSize']
        line2 = translate("line2") % (stat['ConnectedSeeders'], stat['ActivePeers'], stat['TotalPeers'])
        line3 = u"D: {0}/сек [{1}/{2}]".format(downSpeed, humanizeSize(preloadedBytes), humanizeSize(preloadSize))
        if preloadSize > 0 and preloadedBytes < preloadSize:
            prc = preloadedBytes * 100 / preloadSize
            if prc > 100:
                prc = 100
            pDialog.update(prc, name, line2, line3)
        elif preloadedBytes > preloadSize:
            success = True
            pDialog.close()
            break
    return success


@plugin.action("install_service")
def installService():
    try:
        import xbmcaddon
        xbmcaddon.Addon('script.service.torrserver')
        notify('TorrServer Service installed')
    except RuntimeError:
        notify("TorrServer not installed")
        import xbmc
        xbmc.executebuiltin("InstallAddon(script.service.torrserver)")


def run():
    plugin.run()
